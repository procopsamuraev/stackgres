pg_replication:
  master: true
  query: |
    select
    case
      when pg_last_wal_receive_lsn() = pg_last_wal_replay_lsn() then 0
      else extract (EPOCH FROM now() - pg_last_xact_replay_timestamp())::integer
    end as lag,
    case
      when pg_is_in_recovery() then 1
      else 0
    end as is_replica;
  metrics:
    - lag:
        usage: "GAUGE"
        description: "Replication lag behind master in seconds"
    - is_replica:
        usage: "GAUGE"
        description: "Indicates if this host is a replica"

pg_postmaster:
  master: true
  query: "SELECT pg_postmaster_start_time as start_time_seconds from pg_postmaster_start_time()"
  metrics:
    - start_time_seconds:
        usage: "GAUGE"
        description: "Time at which postmaster started"

pg_stat_user_tables:
  master: true
  query: |
    SET max_parallel_workers_per_gather = 0;
    WITH databases AS (
      SELECT datname FROM pg_database
      WHERE datname NOT IN ('template0', 'template1')
    )
    SELECT datname, ss.* FROM databases,
      LATERAL (SELECT * FROM dblink(
        'host=/var/run/postgresql port=5432 user=postgres sslmode=disable dbname=''' || regexp_replace(datname, '([.\\])', '\\\1', 'g') || '''',
        'SELECT schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd, n_tup_del, n_tup_hot_upd, n_live_tup, n_dead_tup, n_mod_since_analyze, COALESCE(last_vacuum, ''1970-01-01Z'') as last_vacuum, COALESCE(last_autovacuum, ''1970-01-01Z'') as last_autovacuum, COALESCE(last_analyze, ''1970-01-01Z'') as last_analyze, COALESCE(last_autoanalyze, ''1970-01-01Z'') as last_autoanalyze, vacuum_count, autovacuum_count, analyze_count, autoanalyze_count FROM pg_catalog.pg_stat_user_tables')
        AS (schemaname name, relname name, seq_scan bigint, seq_tup_read bigint, idx_scan bigint, idx_tup_fetch bigint, n_tup_ins bigint, n_tup_upd bigint, n_tup_del bigint, n_tup_hot_upd bigint, n_live_tup bigint, n_dead_tup bigint, n_mod_since_analyze bigint, last_vacuum timestamp with time zone, last_autovacuum timestamp with time zone, last_analyze timestamp with time zone, last_autoanalyze timestamp with time zone, vacuum_count bigint, autovacuum_count bigint, analyze_count bigint, autoanalyze_count bigint)) AS ss;
  metrics:
    - datname:
        usage: "LABEL"
        description: "Name of current database"
    - schemaname:
        usage: "LABEL"
        description: "Name of the schema that this table is in"
    - relname:
        usage: "LABEL"
        description: "Name of this table"
    - seq_scan:
        usage: "COUNTER"
        description: "Number of sequential scans initiated on this table"
    - seq_tup_read:
        usage: "COUNTER"
        description: "Number of live rows fetched by sequential scans"
    - idx_scan:
        usage: "COUNTER"
        description: "Number of index scans initiated on this table"
    - idx_tup_fetch:
        usage: "COUNTER"
        description: "Number of live rows fetched by index scans"
    - n_tup_ins:
        usage: "COUNTER"
        description: "Number of rows inserted"
    - n_tup_upd:
        usage: "COUNTER"
        description: "Number of rows updated"
    - n_tup_del:
        usage: "COUNTER"
        description: "Number of rows deleted"
    - n_tup_hot_upd:
        usage: "COUNTER"
        description: "Number of rows HOT updated (i.e., with no separate index update required)"
    - n_live_tup:
        usage: "GAUGE"
        description: "Estimated number of live rows"
    - n_dead_tup:
        usage: "GAUGE"
        description: "Estimated number of dead rows"
    - n_mod_since_analyze:
        usage: "GAUGE"
        description: "Estimated number of rows changed since last analyze"
    - last_vacuum:
        usage: "GAUGE"
        description: "Last time at which this table was manually vacuumed (not counting VACUUM FULL)"
    - last_autovacuum:
        usage: "GAUGE"
        description: "Last time at which this table was vacuumed by the autovacuum daemon"
    - last_analyze:
        usage: "GAUGE"
        description: "Last time at which this table was manually analyzed"
    - last_autoanalyze:
        usage: "GAUGE"
        description: "Last time at which this table was analyzed by the autovacuum daemon"
    - vacuum_count:
        usage: "COUNTER"
        description: "Number of times this table has been manually vacuumed (not counting VACUUM FULL)"
    - autovacuum_count:
        usage: "COUNTER"
        description: "Number of times this table has been vacuumed by the autovacuum daemon"
    - analyze_count:
        usage: "COUNTER"
        description: "Number of times this table has been manually analyzed"
    - autoanalyze_count:
        usage: "COUNTER"
        description: "Number of times this table has been analyzed by the autovacuum daemon"

pg_statio_user_tables:
  master: true
  query: |
    SET max_parallel_workers_per_gather = 0;
    WITH databases AS (
      SELECT datname FROM pg_database
      WHERE datname NOT IN ('template0', 'template1')
    )
    SELECT datname, ss.* FROM databases,
      LATERAL (SELECT * FROM dblink(
        'host=/var/run/postgresql port=5432 user=postgres sslmode=disable dbname=''' || regexp_replace(datname, '([.\\])', '\\\1', 'g') || '''',
        'SELECT schemaname, relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit, toast_blks_read, toast_blks_hit, tidx_blks_read, tidx_blks_hit FROM pg_catalog.pg_statio_user_tables')
        AS (schemaname name, relname name, heap_blks_read bigint, heap_blks_hit bigint, idx_blks_read bigint, idx_blks_hit bigint, toast_blks_read bigint, toast_blks_hit bigint, tidx_blks_read bigint, tidx_blks_hit bigint)) AS ss;
  metrics:
    - datname:
        usage: "LABEL"
        description: "Name of current database"
    - schemaname:
        usage: "LABEL"
        description: "Name of the schema that this table is in"
    - relname:
        usage: "LABEL"
        description: "Name of this table"
    - heap_blks_read:
        usage: "COUNTER"
        description: "Number of disk blocks read from this table"
    - heap_blks_hit:
        usage: "COUNTER"
        description: "Number of buffer hits in this table"
    - idx_blks_read:
        usage: "COUNTER"
        description: "Number of disk blocks read from all indexes on this table"
    - idx_blks_hit:
        usage: "COUNTER"
        description: "Number of buffer hits in all indexes on this table"
    - toast_blks_read:
        usage: "COUNTER"
        description: "Number of disk blocks read from this table's TOAST table (if any)"
    - toast_blks_hit:
        usage: "COUNTER"
        description: "Number of buffer hits in this table's TOAST table (if any)"
    - tidx_blks_read:
        usage: "COUNTER"
        description: "Number of disk blocks read from this table's TOAST table indexes (if any)"
    - tidx_blks_hit:
        usage: "COUNTER"
        description: "Number of buffer hits in this table's TOAST table indexes (if any)"

pg_stat_user_indexes:
  master: true
  query: |
    SET max_parallel_workers_per_gather = 0;
    WITH databases AS (
      SELECT datname FROM pg_database
      WHERE datname NOT IN ('template0', 'template1')
    )
    SELECT datname, ss.* FROM databases,
      LATERAL (SELECT * FROM dblink(
        'host=/var/run/postgresql port=5432 user=postgres sslmode=disable dbname=''' || regexp_replace(datname, '([.\\])', '\\\1', 'g') || '''',
        'SELECT schemaname, relname, indexrelname, idx_scan, idx_tup_read, idx_tup_fetch FROM pg_catalog.pg_stat_user_indexes')
        AS (schemaname name, relname name, indexrelname name, idx_scan bigint, idx_tup_read bigint, idx_tup_fetch bigint)) AS ss;
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - schemaname:
        usage: "LABEL"
        description: "Name of the schema that this table is in"
    - relname:
        usage: "LABEL"
        description: "Name of the table for this index"
    - indexrelname:
        usage: "LABEL"
        description: "Name of this index"
    - idx_scan:
        usage: "COUNTER"
        description: "Number of index scans initiated on this index"
    - idx_tup_read:
        usage: "COUNTER"
        description: "Number of index entries returned by scans on this index"
    - idx_tup_fetch:
        usage: "COUNTER"
        description: "Number of live table rows fetched by simple index scans using this index"

pg_statio_user_indexes:
  master: true
  query: |
    SET max_parallel_workers_per_gather = 0;
    WITH databases AS (
      SELECT datname FROM pg_database
      WHERE datname NOT IN ('template0', 'template1')
    )
    SELECT datname, ss.* FROM databases,
      LATERAL (SELECT * FROM dblink(
        'host=/var/run/postgresql port=5432 user=postgres sslmode=disable dbname=''' || regexp_replace(datname, '([.\\])', '\\\1', 'g') || '''',
        'SELECT schemaname, relname, indexrelname, idx_blks_read, idx_blks_hit FROM pg_catalog.pg_statio_user_indexes')
        AS (schemaname name, relname name, indexrelname name, idx_blks_read bigint, idx_blks_hit bigint)) AS ss;
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - schemaname:
        usage: "LABEL"
        description: "Name of the schema that this table is in"
    - relname:
        usage: "LABEL"
        description: "Name of the table for this index"
    - indexrelname:
        usage: "LABEL"
        description: "Name of this index"
    - idx_blks_read:
        usage: "COUNTER"
        description: "Number of disk blocks read from this index"
    - idx_blks_hit:
        usage: "COUNTER"
        description: "Number of buffer hits in this index"

pg_total_relation_size:
  master: true
  query: |
    SET max_parallel_workers_per_gather = 0;
    WITH databases AS (
      SELECT datname FROM pg_database
      WHERE datname NOT IN ('template0', 'template1')
    )
    SELECT datname, ss.* FROM databases,
      LATERAL (SELECT * FROM dblink(
        'host=/var/run/postgresql port=5432 user=postgres sslmode=disable dbname=''' || regexp_replace(datname, '([.\\])', '\\\1', 'g') || '''',
        'SELECT relnamespace::regnamespace as schemaname, relname as relname, pg_total_relation_size(oid) bytes FROM pg_catalog.pg_class WHERE relkind = ''r''')
        AS (schemaname name, relname name, bytes bigint)) AS ss;
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - schemaname:
        usage: "LABEL"
        description: "Name of the schema that table is in"
    - relname:
        usage: "LABEL"
        description: "Name of this table"
    - bytes:
        usage: "GAUGE"
        description: "Total disk space usage for the specified table and associated indexes"

pg_blocked:
  master: true
  query: |
    SET max_parallel_workers_per_gather = 0;
    WITH databases AS (
      SELECT oid, datname FROM pg_database
      WHERE datname NOT IN ('template0', 'template1')
    )
    SELECT
      locktype AS type,
      NULL AS datname,
      NULL AS schemaname,
      NULL AS reltype,
      NULL AS relname,
      count(*) AS queries
    FROM pg_catalog.pg_locks blocked
    WHERE NOT blocked.granted AND relation IS NULL
    GROUP BY locktype
    UNION
    SELECT
      locktype AS type,
      datname,
      schemaname,
      CASE relkind
        WHEN 'r' THEN 'ordinary table'
        WHEN 'i' THEN 'index'
        WHEN 'S' THEN 'sequence'
        WHEN 't' THEN 'TOAST table'
        WHEN 'v' THEN 'view'
        WHEN 'm' THEN 'materialized view'
        WHEN 'c' THEN 'composite type'
        WHEN 'f' THEN 'foreign table'
        WHEN 'p' THEN 'partitioned table'
        WHEN 'I' THEN 'partitioned index'
        ELSE 'unknown type ''' || relkind || ''''
        END AS reltype,
      relname,
      count(*) AS queries
    FROM pg_catalog.pg_locks blocked
    INNER JOIN databases
      ON blocked.database = databases.oid,
      LATERAL (SELECT * FROM dblink(
        'host=/var/run/postgresql port=5432 user=postgres sslmode=disable dbname=''' || regexp_replace(datname, '([.\\])', '\\\1', 'g') || '''',
        'SELECT nspname as schemaname, relkind, relname FROM pg_catalog.pg_class LEFT JOIN pg_catalog.pg_namespace ON (pg_namespace.oid = relnamespace) WHERE pg_class.oid = ' || blocked.relation)
        AS (schemaname name, relkind char, relname name)) AS ss
    WHERE NOT blocked.granted AND relation IS NOT NULL
    GROUP BY locktype, datname, schemaname, reltype, relname
  metrics:
    - type:
        usage: "LABEL"
        description: "The lock type"
    - datname:
        usage: "LABEL"
        description: "Database name"
    - schemaname:
        usage: "LABEL"
        description: "The schema on which a query is blocked"
    - reltype:
        usage: "LABEL"
        description: "The type of relation"
    - relname:
        usage: "LABEL"
        description: "The relation on which a query is blocked"
    - queries:
        usage: "GAUGE"
        description: "The current number of blocked queries"

pg_oldest_blocked:
  master: true
  query: |
    SELECT datname,
      coalesce(extract('epoch' from max(clock_timestamp() - state_change)), 0) age_seconds
    FROM pg_catalog.pg_stat_activity
    WHERE wait_event_type = 'Lock'
    AND state='active'
    GROUP BY datname
  metrics:
    - age_seconds:
        usage: "GAUGE"
        description: "Largest number of seconds any transaction is currently waiting on a lock"
    - datname:
        usage: "LABEL"
        description: "Database name"

pg_slow:
  master: true
  query: |
    SELECT datname, COUNT(*) AS queries
    FROM pg_catalog.pg_stat_activity
    WHERE state = 'active' AND (now() - query_start) > '1 seconds'::interval
    GROUP BY datname;
  metrics:
    - queries:
        usage: "GAUGE"
        description: "Current number of slow queries"
    - datname:
        usage: "LABEL"
        description: "Database name"

pg_long_running_transactions:
  master: true
  query: |
    SELECT datname, COUNT(*) as transactions,
    MAX(EXTRACT(EPOCH FROM (clock_timestamp() - xact_start))) AS age_in_seconds
    FROM pg_catalog.pg_stat_activity
    WHERE state is distinct from 'idle' AND (now() - xact_start) > '1 minutes'::interval AND query not like '%VACUUM%'
    GROUP BY datname
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - queries:
        usage: "GAUGE"
        description: "Current number of long running transactions"
    - age_in_seconds:
        usage: "GAUGE"
        description: "The current maximum transaction age in seconds"

pg_vacuum:
  master: true
  query: |
    SELECT
      datname,
      COUNT(*) AS queries,
      MAX(EXTRACT(EPOCH FROM (clock_timestamp() - query_start))) AS age_in_seconds
    FROM pg_catalog.pg_stat_activity
    WHERE state = 'active' AND trim(query) ~* '\AVACUUM (?!ANALYZE)'
    GROUP BY datname
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - queries:
        usage: "GAUGE"
        description: "The current number of VACUUM queries"
    - age_in_seconds:
        usage: "GAUGE"
        description: "The current maximum VACUUM query age in seconds"

pg_vacuum_analyze:
  master: true
  query: |
    SELECT
      datname,
      COUNT(*) AS queries,
      MAX(EXTRACT(EPOCH FROM (clock_timestamp() - query_start))) AS age_in_seconds
    FROM pg_catalog.pg_stat_activity
    WHERE state = 'active' AND trim(query) ~* '\AVACUUM ANALYZE'
    GROUP BY datname
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - queries:
        usage: "GAUGE"
        description: "The current number of VACUUM ANALYZE queries"
    - age_in_seconds:
        usage: "GAUGE"
        description: "The current maximum VACUUM ANALYZE query age in seconds"

pg_stuck_idle_in_transaction:
  master: true
  query: |
    SELECT datname,
      COUNT(*) AS queries
    FROM pg_catalog.pg_stat_activity
    WHERE state = 'idle in transaction' AND (now() - query_start) > '10 minutes'::interval
    GROUP BY datname
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - queries:
        usage: "GAUGE"
        description: "Current number of queries that are stuck being idle in transactions"

pg_txid:
  master: true
  query: |
    SELECT
      CASE WHEN pg_is_in_recovery() THEN 'NaN'::float ELSE txid_current() % (2^52)::bigint END AS current,
      CASE WHEN pg_is_in_recovery() THEN 'NaN'::float ELSE txid_snapshot_xmin(txid_current_snapshot()) % (2^52)::bigint END AS xmin,
      CASE WHEN pg_is_in_recovery() THEN 'NaN'::float ELSE txid_current() - txid_snapshot_xmin(txid_current_snapshot()) END AS xmin_age
  metrics:
    - current:
        usage: "COUNTER"
        description: "Current 64-bit transaction id of the query used to collect this metric (truncated to low 52 bits)"
    - xmin:
        usage: "COUNTER"
        description: "Oldest transaction id of a transaction still in progress, i.e. not known committed or aborted (truncated to low 52 bits)"
    - xmin_age:
        usage: "GAUGE"
        description: "Age of oldest transaction still not committed or aborted measured in transaction ids"

pg_database_datfrozenxid:
  master: true
  query: "SELECT datname, age(datfrozenxid) AS age FROM pg_catalog.pg_database"
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database Name"
    - age:
        usage: "GAUGE"
        description: "Age of the oldest transaction that has not been frozen."

pg_wal_position:
  master: true
  query: |
    SELECT CASE
           WHEN pg_is_in_recovery()
           THEN (pg_last_wal_receive_lsn() - '0/0') % (2^52)::bigint
           ELSE (pg_current_wal_lsn() - '0/0') % (2^52)::bigint
           END AS bytes
  metrics:
    - bytes:
        usage: "COUNTER"
        description: "Postgres LSN (log sequence number) being generated on primary or replayed on replica (truncated to low 52 bits)"


pg_replication_slots:
  master: true
  query: |
    SELECT slot_name, slot_type,
           case when active then 1.0 else 0.0 end AS active,
           age(xmin) AS xmin_age,
           age(catalog_xmin) AS catalog_xmin_age,
           CASE WHEN pg_is_in_recovery() THEN pg_last_wal_receive_lsn() ELSE pg_current_wal_lsn() END - restart_lsn AS restart_lsn_bytes,
           CASE WHEN pg_is_in_recovery() THEN pg_last_wal_receive_lsn() ELSE pg_current_wal_lsn() END - confirmed_flush_lsn AS confirmed_flush_lsn_bytes
      FROM pg_catalog.pg_replication_slots
  metrics:
    - slot_name:
        usage: "LABEL"
        description: "Slot Name"
    - slot_type:
        usage: "LABEL"
        description: "Slot Type"
    - active:
        usage: "GAUGE"
        description: "Boolean flag indicating whether this slot has a consumer streaming from it"
    - xmin_age:
        usage: "GAUGE"
        description: "Age of oldest transaction that cannot be vacuumed due to this replica"
    - catalog_xmin_age:
        usage: "GAUGE"
        description: "Age of oldest transaction that cannot be vacuumed from catalogs due to this replica (used by logical replication)"
    - restart_lsn_bytes:
        usage: "GAUGE"
        description: "Amount of data on in xlog that must be this replica may need to complete recovery"
    - confirmed_flush_lsn_bytes:
        usage: "GAUGE"
        description: "Amount of data on in xlog that must be this replica has not yet received"

pg_table_bloat:
  master: true
  query: |
    SET max_parallel_workers_per_gather = 0;
    WITH databases AS (
      SELECT datname FROM pg_database
      WHERE datname NOT IN ('template0', 'template1')
    )
    SELECT datname, ss.* FROM databases,
    LATERAL (SELECT * FROM dblink(
        'host=/var/run/postgresql port=5432 user=postgres sslmode=disable dbname=''' || regexp_replace(datname, '([.\\])', '\\\1', 'g') || '''',
        '-- https://github.com/ioguix/pgsql-bloat-estimation' || E'\n'
        || ' SELECT schemaname, tablename, bs*tblpages AS real_size,' || E'\n'
        || ' (tblpages-est_tblpages)*bs AS extra_size,' || E'\n'
        || ' CASE WHEN tblpages - est_tblpages > 0' || E'\n'
        || '     THEN 100 * (tblpages - est_tblpages)/tblpages::float' || E'\n'
        || '     ELSE 0' || E'\n'
        || ' END AS extra_ratio, fillfactor,' || E'\n'
        || ' CASE WHEN tblpages - est_tblpages_ff > 0' || E'\n'
        || '     THEN (tblpages-est_tblpages_ff)*bs' || E'\n'
        || '     ELSE 0' || E'\n'
        || ' END AS bloat_size,' || E'\n'
        || ' CASE WHEN tblpages - est_tblpages_ff > 0' || E'\n'
        || '     THEN 100 * (tblpages - est_tblpages_ff)/tblpages::float' || E'\n'
        || '     ELSE 0' || E'\n'
        || ' END AS bloat_ratio, is_na' || E'\n'
        || ' FROM (' || E'\n'
        || ' SELECT ceil( reltuples / ( (bs-page_hdr)/tpl_size ) ) + ceil( toasttuples / 4 ) AS est_tblpages,' || E'\n'
        || '     ceil( reltuples / ( (bs-page_hdr)*fillfactor/(tpl_size*100) ) ) + ceil( toasttuples / 4 ) AS est_tblpages_ff,' || E'\n'
        || '     tblpages, fillfactor, bs, tblid, schemaname, tablename, heappages, toastpages, is_na' || E'\n'
        || ' FROM (' || E'\n'
        || '     SELECT' || E'\n'
        || '     ( 4 + tpl_hdr_size + tpl_data_size + (2*ma)' || E'\n'
        || '         - CASE WHEN tpl_hdr_size%ma = 0 THEN ma ELSE tpl_hdr_size%ma END' || E'\n'
        || '         - CASE WHEN ceil(tpl_data_size)::int%ma = 0 THEN ma ELSE ceil(tpl_data_size)::int%ma END' || E'\n'
        || '     ) AS tpl_size, bs - page_hdr AS size_per_block, (heappages + toastpages) AS tblpages, heappages,' || E'\n'
        || '     toastpages, reltuples, toasttuples, bs, page_hdr, tblid, schemaname, tablename, fillfactor, is_na' || E'\n'
        || '     FROM (' || E'\n'
        || '     SELECT' || E'\n'
        || '         tbl.oid AS tblid, ns.nspname AS schemaname, tbl.relname AS tablename, tbl.reltuples,' || E'\n'
        || '         tbl.relpages AS heappages, coalesce(toast.relpages, 0) AS toastpages,' || E'\n'
        || '         coalesce(toast.reltuples, 0) AS toasttuples,' || E'\n'
        || '         coalesce(substring(' || E'\n'
        || '         array_to_string(tbl.reloptions, '' '')' || E'\n'
        || '         FROM ''fillfactor=([0-9]+)'')::smallint, 100) AS fillfactor,' || E'\n'
        || '         current_setting(''block_size'')::numeric AS bs,' || E'\n'
        || '         CASE WHEN version()~''mingw32'' OR version()~''64-bit|x86_64|ppc64|ia64|amd64'' THEN 8 ELSE 4 END AS ma,' || E'\n'
        || '         24 AS page_hdr,' || E'\n'
        || '         23 + CASE WHEN MAX(coalesce(s.null_frac,0)) > 0 THEN ( 7 + count(s.attname) ) / 8 ELSE 0::int END' || E'\n'
        || '         + CASE WHEN bool_or(att.attname = ''oid'' and att.attnum < 0) THEN 4 ELSE 0 END AS tpl_hdr_size,' || E'\n'
        || '         sum( (1-coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 0) ) AS tpl_data_size,' || E'\n'
        || '         bool_or(att.atttypid = ''pg_catalog.name''::regtype)' || E'\n'
        || '         OR sum(CASE WHEN att.attnum > 0 THEN 1 ELSE 0 END) <> count(s.attname) AS is_na' || E'\n'
        || '     FROM pg_attribute AS att' || E'\n'
        || '         JOIN pg_class AS tbl ON att.attrelid = tbl.oid' || E'\n'
        || '         JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace' || E'\n'
        || '         LEFT JOIN pg_stats AS s ON s.schemaname=ns.nspname' || E'\n'
        || '         AND s.tablename = tbl.relname AND s.inherited=false AND s.attname=att.attname' || E'\n'
        || '         LEFT JOIN pg_class AS toast ON tbl.reltoastrelid = toast.oid' || E'\n'
        || '     WHERE NOT att.attisdropped' || E'\n'
        || '         AND tbl.relkind in (''r'',''m'')' || E'\n'
        || '     GROUP BY 1,2,3,4,5,6,7,8,9,10' || E'\n'
        || '     ORDER BY 2,3' || E'\n'
        || '     ) AS s' || E'\n'
        || ' ) AS s2' || E'\n'
        || ' ) AS s3' || E'\n'
        || ' where schemaname not in (''information_schema'',''pg_catalog'')' || E'\n'
        || ' ORDER BY schemaname, tablename' || E'\n')
       As (schemaname character varying, tablename character varying, real_size numeric, extra_size numeric, extra_ratio numeric, fillfactor numeric, bloat_size numeric, bloat_ratio numeric, is_na boolean)) AS ss;
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database Name"
    - schemaname:
        usage: "LABEL"
        description: "Schema Name"
    - tablename:
        usage: "LABEL"
        description: "Table Name"
    - real_size:
        usage: "GAUGE"
        description: "Table real size"
    - extra_size:
        usage: "GAUGE"
        description: "Estimated extra size not used/needed in the table. This extra size is composed by the fillfactor, bloat and alignment padding spaces"
    - extra_ratio:
        usage: "GAUGE"
        description: "Estimated ratio of the real size used by extra_size"
    - fillfactor:
        usage: "GAUGE"
        description: "Table fillfactor"
    - bloat_size:
        usage: "GAUGE"
        description: "Estimated size of the bloat without the extra space kept for the fillfactor."
    - bloat_ratio:
        usage: "GAUGE"
        description: "Estimated ratio of the real size used by bloat_size"
    - is_na:
        usage: "GAUGE"
        description: "Estimation not aplicable, If true, do not trust the stats"

pg_index:
  master: true
  query: |
    SET max_parallel_workers_per_gather = 0;
    WITH databases AS (
      SELECT datname FROM pg_database
      WHERE datname NOT IN ('template0', 'template1')
    )
    SELECT datname, ss.* FROM databases,
    LATERAL (SELECT * FROM dblink(
        'host=/var/run/postgresql port=5432 user=postgres sslmode=disable dbname=''' || regexp_replace(datname, '([.\\])', '\\\1', 'g') || '''',
        '-- https://github.com/ioguix/pgsql-bloat-estimation' || E'\n'
      || ' SELECT nspname AS schema_name, tblname, idxname, bs*(relpages)::bigint AS real_size,' || E'\n'
      || '  bs*(relpages-est_pages)::bigint AS extra_size,' || E'\n'
      || '  100 * (relpages-est_pages)::float / relpages AS extra_ratio,' || E'\n'
      || '  fillfactor,' || E'\n'
      || '  CASE WHEN relpages > est_pages_ff' || E'\n'
      || '  THEN bs*(relpages-est_pages_ff)' || E'\n'
      || '  ELSE 0' || E'\n'
      || '  END AS bloat_size,' || E'\n'
      || '  100 * (relpages-est_pages_ff)::float / relpages AS bloat_ratio,' || E'\n'
      || '  is_na' || E'\n'
      || '  FROM (' || E'\n'
      || '  SELECT coalesce(1 +' || E'\n'
      || '          ceil(reltuples/floor((bs-pageopqdata-pagehdr)/(4+nulldatahdrwidth)::float)), 0' || E'\n'
      || '      ) AS est_pages,' || E'\n'
      || '      coalesce(1 +' || E'\n'
      || '          ceil(reltuples/floor((bs-pageopqdata-pagehdr)*fillfactor/(100*(4+nulldatahdrwidth)::float))), 0' || E'\n'
      || '      ) AS est_pages_ff,' || E'\n'
      || '      bs, nspname, tblname, idxname, relpages, fillfactor, is_na' || E'\n'
      || '  FROM (' || E'\n'
      || '      SELECT maxalign, bs, nspname, tblname, idxname, reltuples, relpages, idxoid, fillfactor,' || E'\n'
      || '          ( index_tuple_hdr_bm +' || E'\n'
      || '              maxalign - CASE -- Add padding to the index tuple header to align on MAXALIGN' || E'\n'
      || '                  WHEN index_tuple_hdr_bm%maxalign = 0 THEN maxalign' || E'\n'
      || '                  ELSE index_tuple_hdr_bm%maxalign' || E'\n'
      || '              END' || E'\n'
      || '              + nulldatawidth + maxalign - CASE -- Add padding to the data to align on MAXALIGN' || E'\n'
      || '                  WHEN nulldatawidth = 0 THEN 0' || E'\n'
      || '                  WHEN nulldatawidth::integer%maxalign = 0 THEN maxalign' || E'\n'
      || '                  ELSE nulldatawidth::integer%maxalign' || E'\n'
      || '              END' || E'\n'
      || '          )::numeric AS nulldatahdrwidth, pagehdr, pageopqdata, is_na' || E'\n'
      || '      FROM (' || E'\n'
      || '          SELECT n.nspname, i.tblname, i.idxname, i.reltuples, i.relpages,' || E'\n'
      || '              i.idxoid, i.fillfactor, current_setting(''block_size'')::numeric AS bs,' || E'\n'
      || '              CASE' || E'\n'
      || '              WHEN version() ~ ''mingw32'' OR version() ~ ''64-bit|x86_64|ppc64|ia64|amd64'' THEN 8' || E'\n'
      || '              ELSE 4' || E'\n'
      || '              END AS maxalign,' || E'\n'
      || '              24 AS pagehdr,' || E'\n'
      || '              16 AS pageopqdata,' || E'\n'
      || '              CASE WHEN max(coalesce(s.null_frac,0)) = 0' || E'\n'
      || '                  THEN 2 -- IndexTupleData size' || E'\n'
      || '                  ELSE 2 + (( 32 + 8 - 1 ) / 8)' || E'\n'
      || '              END AS index_tuple_hdr_bm,' || E'\n'
      || '              sum( (1-coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024)) AS nulldatawidth,' || E'\n'
      || '              max( CASE WHEN i.atttypid = ''pg_catalog.name''::regtype THEN 1 ELSE 0 END ) > 0 AS is_na' || E'\n'
      || '          FROM (' || E'\n'
      || '              SELECT ct.relname AS tblname, ct.relnamespace, ic.idxname, ic.attpos, ic.indkey, ic.indkey[ic.attpos], ic.reltuples, ic.relpages, ic.tbloid, ic.idxoid, ic.fillfactor,' || E'\n'
      || '                  coalesce(a1.attnum, a2.attnum) AS attnum, coalesce(a1.attname, a2.attname) AS attname, coalesce(a1.atttypid, a2.atttypid) AS atttypid,' || E'\n'
      || '                  CASE WHEN a1.attnum IS NULL' || E'\n'
      || '                  THEN ic.idxname' || E'\n'
      || '                  ELSE ct.relname' || E'\n'
      || '                  END AS attrelname' || E'\n'
      || '              FROM (' || E'\n'
      || '                  SELECT idxname, reltuples, relpages, tbloid, idxoid, fillfactor, indkey,' || E'\n'
      || '                      pg_catalog.generate_series(1,indnatts) AS attpos' || E'\n'
      || '                  FROM (' || E'\n'
      || '                      SELECT ci.relname AS idxname, ci.reltuples, ci.relpages, i.indrelid AS tbloid,' || E'\n'
      || '                          i.indexrelid AS idxoid,' || E'\n'
      || '                          coalesce(substring(' || E'\n'
      || '                              array_to_string(ci.reloptions, '' '')' || E'\n'
      || '                              from ''fillfactor=([0-9]+)'')::smallint, 90) AS fillfactor,' || E'\n'
      || '                          i.indnatts,' || E'\n'
      || '                          pg_catalog.string_to_array(pg_catalog.textin(' || E'\n'
      || '                              pg_catalog.int2vectorout(i.indkey)),'' '')::int[] AS indkey' || E'\n'
      || '                      FROM pg_catalog.pg_index i' || E'\n'
      || '                      JOIN pg_catalog.pg_class ci ON ci.oid = i.indexrelid' || E'\n'
      || '                      WHERE ci.relam=(SELECT oid FROM pg_am WHERE amname = ''btree'')' || E'\n'
      || '                      AND ci.relpages > 0' || E'\n'
      || '                  ) AS idx_data' || E'\n'
      || '              ) AS ic' || E'\n'
      || '              JOIN pg_catalog.pg_class ct ON ct.oid = ic.tbloid' || E'\n'
      || '              LEFT JOIN pg_catalog.pg_attribute a1 ON' || E'\n'
      || '                  ic.indkey[ic.attpos] <> 0' || E'\n'
      || '                  AND a1.attrelid = ic.tbloid' || E'\n'
      || '                  AND a1.attnum = ic.indkey[ic.attpos]' || E'\n'
      || '              LEFT JOIN pg_catalog.pg_attribute a2 ON' || E'\n'
      || '                  ic.indkey[ic.attpos] = 0' || E'\n'
      || '                  AND a2.attrelid = ic.idxoid' || E'\n'
      || '                  AND a2.attnum = ic.attpos' || E'\n'
      || '          ) i' || E'\n'
      || '          JOIN pg_catalog.pg_namespace n ON n.oid = i.relnamespace' || E'\n'
      || '          JOIN pg_catalog.pg_stats s ON s.schemaname = n.nspname' || E'\n'
      || '                                      AND s.tablename = i.attrelname' || E'\n'
      || '                                      AND s.attname = i.attname' || E'\n'
      || '          GROUP BY 1,2,3,4,5,6,7,8,9,10,11' || E'\n'
      || '      ) AS rows_data_stats' || E'\n'
      || '  ) AS rows_hdr_pdg_stats' || E'\n'
      || '  ) AS relation_stats' || E'\n'
      || '  WHERE nspname != ''pg_catalog'' ' || E'\n'
      || '  ORDER BY nspname, tblname, idxname;' || E'\n')
      As (schema_name character varying, tblname character varying, idxname character varying, real_size numeric, extra_size numeric, extra_ratio numeric, fillfactor numeric, bloat_size numeric, bloat_ratio numeric, is_na boolean)) AS ss;
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database Name"
    - schema_name:
        usage: "LABEL"
        description: "Schema Name"
    - tblname:
        usage: "LABEL"
        description: "Table Name"
    - idxname:
        usage: "LABEL"
        description: "Index Name"
    - real_size:
        usage: "GAUGE"
        description: "Index size"
    - extra_size:
        usage: "GAUGE"
        description: "Index extra size"
    - extra_ratio:
        usage: "GAUGE"
        description: "Index extra size ratio"
    - fillfactor:
        usage: "GAUGE"
        description: "Fillfactor"
    - bloat_size:
        usage: "GAUGE"
        description: "Estimate index bloat size"
    - bloat_ratio:
        usage: "GAUGE"
        description: "Estimate index bloat size ratio"
    - is_na:
        usage: "GAUGE"
        description: "Estimate Not aplicable, bad statistic"

pg_replication_status:
  master: true
  query: |
    select application_name,
    client_addr,
    state,
    pg_wal_lsn_diff(pg_stat_replication.sent_lsn, pg_stat_replication.replay_lsn) AS lag_size
    FROM pg_stat_replication;
  metrics:
    - application_name:
        usage: "LABEL"
        description: "Application or node name"
    - client_addr:
        usage: "LABEL"
        description: "Client ip address"
    - state:
        usage: "LABEL"
        description: "Client replication state"
    - lag_size_bytes:
        usage: "GAUGE"
        description: "Replication lag size in bytes"

pg_vaccuum_wraparound:
  master: true
  query: |
    SET max_parallel_workers_per_gather = 0;
    WITH databases AS (
    SELECT datname FROM pg_database
    WHERE datname NOT IN ('template0', 'template1')
    )
    SELECT datname, ss.* FROM databases,
    LATERAL (SELECT * FROM dblink(
        'host=/var/run/postgresql port=5432 user=postgres sslmode=disable dbname=''' || regexp_replace(datname, '([.\\])', '\\\1', 'g') || '''',
        '
        WITH tabfreeze AS (
            SELECT pg_class.oid::regclass AS full_table_name,
            greatest(age(pg_class.relfrozenxid), age(toast.relfrozenxid)) as freeze_age,
            pg_total_relation_size(pg_class.oid),
            case
                    when array_to_string(pg_class.reloptions, '''') like ''%autovacuum_freeze_max_age%'' then regexp_replace(array_to_string(pg_class.reloptions, ''''), ''.*autovacuum_freeze_max_age=([0-9.]+).*'', E''\\1'')::int8
                    else current_setting(''autovacuum_freeze_max_age'')::int8
                end as autovacuum_freeze_max_age
        FROM pg_class JOIN pg_namespace ON pg_class.relnamespace = pg_namespace.oid
            LEFT OUTER JOIN pg_class as toast
                ON pg_class.reltoastrelid = toast.oid
        WHERE nspname not in (''pg_catalog'', ''information_schema'')
            AND nspname NOT LIKE ''pg_temp%''
            AND pg_class.relkind = ''r''
        )
        SELECT full_table_name,  pg_total_relation_size,freeze_age,autovacuum_freeze_max_age, (freeze_age*1)::bigint/(autovacuum_freeze_max_age/100) as "percent"
        FROM tabfreeze
        WHERE pg_total_relation_size >=  10000000000 -- size of table 10 GB
        AND (freeze_age*1)::bigint/(autovacuum_freeze_max_age/100)>=90 --percent of txid
        ORDER BY 5 DESC;

        ')
        AS (full_table_name name, table_size bigint, freeze_age bigint, autovacuum_freeze_max_age bigint, percent integer)) AS ss;
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - full_table_name:
        usage: "LABEL"
        description: "Full table name"
    - table_size:
        usage: "GAUGE"
        description: "Table size"
    - freeze_age:
        usage: "GAUGE"
        description: "Freeze age"
    - autovacuum_freeze_max_age:
        usage: "GAUGE"
        description: "Autovacuum freeze max age"
    - percent:
        usage: "GAUGE"
        description: "Percentage"

# CURRENT ACTIVITY
pg_current_activity:
  master: true
  query: |
    SELECT
        coalesce(datname,current_database()) as datname, pid, usename, application_name, backend_type,
        CASE
        WHEN client_port IS NULL THEN 'internal'
        WHEN client_port = -1 THEN 'socket'
        ELSE 'host' END AS client_type,
        state,
        wait_event,
        wait_event_type,
        EXTRACT(EPOCH FROM (clock_timestamp()-backend_start)) AS backend_duration,
        EXTRACT(EPOCH FROM (clock_timestamp()-query_start)) AS query_duration,
        EXTRACT(EPOCH FROM (clock_timestamp()-xact_start)) AS xact_duration,
        EXTRACT(EPOCH FROM (clock_timestamp()-state_change)) AS state_duration,
        leader_pid, backend_xid, backend_xmin, query_id,query::char(100)
    FROM pg_stat_activity
  metrics:
    - datname:
        usage: "LABEL"
        description: "Name of the database"
    - usename:
        usage: "LABEL"
        description: "Name of the user"
    - application_name:
        usage: "LABEL"
        description: "Name of the application"
    - backend_type:
        usage: "LABEL"
        description: "Type of backend"
    - client_type:
        usage: "LABEL"
        description: "Type of client"
    - state:
        usage: "LABEL"
        description: "Current overall state of this backend."
    - wait_event:
        usage: "LABEL"
        description: "Wait event name"
    - wait_event_type:
        usage: "LABEL"
        description: "The type of event for which the backend is waiting, if any; otherwise NULL"
    - pid:
        usage: "GAUGE"
        description: "Process ID of this backend"
    - leader_pid:
        usage: "LABEL"
        description: "Process ID of the parallel group leader, if this process is a parallel query worker. NULL if this process is a parallel group leader or does not participate in parallel query"
    - backend_duration:
        usage: "LABEL"
        description: "Duration of the backend, in seconds"
    - query_duration:
        usage: "GAUGE"
        description: "Duration of the latest query, in seconds"
    - xact_duration:
        usage: "GAUGE"
        description: "Duration of the latest transaction, in seconds"
    - state_duration:
        usage: "GAUGE"
        description: "Duration of the latest state, in seconds"
    - backend_xid:
        usage: "GAUGE"
        description: "Top-level transaction identifier of this backend, if any"
    - backend_xmin:
        usage: "GAUGE"
        description: "The current backend's xmin horizon"
    - query_id:
        usage: "GAUGE"
        description: "Query ID"
    - query_id:
        usage: "LABEL"
        description: "Query"

pg_stat_current_waiting_query:
  query: |
    SELECT
        datname, wait_event, count(*) AS count
    FROM pg_stat_activity
    WHERE state = 'active' AND wait_event IS NOT NULL
    GROUP BY datname, wait_event;
  master: true
  metrics:
    - datname:
        usage: "LABEL"
        description: "Name of the database"
    - wait_event:
        usage: "LABEL"
        description: "Name of the wait event"
    - count:
        usage: "GAUGE"
        description: "# of queries waiting for other process to finish"

pg_stat_progress_vacuum:
  query: |
    SELECT
        pid, datid, datname, relid, phase, heap_blks_total, heap_blks_scanned,
        heap_blks_vacuumed , index_vacuum_count , max_dead_tuples , num_dead_tuples
    FROM pg_stat_progress_vacuum
  master: true
  metrics:
    - pid:
        usage: "GAUGE"
        description: "Process ID of backend."
    - datid:
        usage: "LABEL"
        description: "OID of the database to which this backend is connected"
    - datname:
        usage: "LABEL"
        description: "Name of the database to which this backend is connected"
    - relid:
        usage: "LABEL"
        description: "OID of the table being vacuumed"
    - phase:
        usage: "LABEL"
        description: "Current processing phase of vacuum"
    - heap_blks_total:
        usage: "LABEL"
        description: "Total number of heap blocks in the table"
    - heap_blks_scanned:
        usage: "LABEL"
        description: "Number of heap blocks scanned"
    - heap_blks_vacuumed:
        usage: "LABEL"
        description: "Number of heap blocks vacuumed"
    - index_vacuum_count:
        usage: "LABEL"
        description: "Number of completed index vacuum cycles"
    - max_dead_tuples:
        usage: "LABEL"
        description: "Number of dead tuples that we can store before needing to perform an index vacuum cycle"
    - num_dead_tuples:
        usage: "LABEL"
        description: "Number of dead tuples collected since the last index vacuum cycle"

pg_stat_progress_cluster:
  query: |
    SELECT
       pid, datid, datname, relid, command, phase, cluster_index_relid,
       heap_tuples_scanned, heap_tuples_written, heap_blks_total,
       heap_blks_scanned, index_rebuild_count
    FROM pg_stat_progress_cluster
  master: true
  metrics:
    - pid:
        usage: "GAUGE"
        description: "Process ID of backend"
    - datid:
        usage: "LABEL"
        description: "OID of the database to which this backend is connected"
    - datname:
        usage: "LABEL"
        description: "Name of the database to which this backend is connected"
    - relid:
        usage: "LABEL"
        description: "OID of the table being clustered"
    - command:
        usage: "LABEL"
        description: "The command that is running. Either CLUSTER or VACUUM FULL"
    - phase:
        usage: "LABEL"
        description: "Current processing phase"
    - cluster_index_relid:
        usage: "LABEL"
        description: "If the table is being scanned using an index, this is the OID of the index being used; otherwise, it is zero"
    - heap_tuples_scanned:
        usage: "LABEL"
        description: "Number of heap tuples scanned. This counter only advances when the phase is seq scanning heap, index scanning heap or writing new heap"
    - heap_tuples_written:
        usage: "LABEL"
        description: "Number of heap tuples written. This counter only advances when the phase is seq scanning heap, index scanning heap or writing new heap"
    - heap_blks_total:
        usage: "LABEL"
        description: "Total number of heap blocks in the table. This number is reported as of the beginning of seq scanning heap"
    - heap_blks_scanned:
        usage: "LABEL"
        description: "Number of heap blocks scanned. This counter only advances when the phase is seq scanning heap"
    - index_rebuild_count:
        usage: "LABEL"
        description: "Number of indexes rebuilt. This counter only advances when the phase is rebuilding index"

# PGBOUNCER QUERIES

pgbouncer_show_clients:
  master: true
  query: |
    SELECT _.type,
    _."user",
    _.database,
    _.state,
    _.addr,
    _.port,
    _.local_addr,
    _.local_port,
    _.connect_time,
    _.request_time,
    _.wait,
    _.wait_us,
    _.close_needed,
    _.ptr,
    _.link,
    _.remote_pid,
    _.tls
    FROM dblink('host=/var/run/postgresql port=6432 dbname=pgbouncer user=pgbouncer', 'show clients'::text)
    _(type text, "user" text, database text, state text, addr text, port integer, local_addr text, local_port integer,
    connect_time timestamp with time zone, request_time timestamp with time zone, wait integer, wait_us integer, close_needed integer,
    ptr text, link text, remote_pid integer, tls text);
  metrics:
    - type:
        usage: "LABEL"
        description: "C, for client."
    - user:
        usage: "LABEL"
        description: "Client connected user"
    - database:
        usage: "LABEL"
        description: "Database name"
    - state:
        usage: "LABEL"
        description: "State of the client connection, one of active or waiting"
    - addr:
        usage: "LABEL"
        description: "IP address of client"
    - port:
        usage: "GAUGE"
        description: "Port client is connected to"
    - local_addr:
        usage: "LABEL"
        description: "Connection end address on local machine"
    - local_port:
        usage: "GAUGE"
        description: "Connection end port on local machine"
    - connect_time:
        usage: "LABEL"
        description: "Timestamp of connect time"
    - request_time:
        usage: "LABEL"
        description: "Timestamp of latest client request"
    - wait:
        usage: "GAUGE"
        description: "Current waiting time in seconds"
    - wait_us:
        usage: "GAUGE"
        description: "Microsecond part of the current waiting time"
    - close_needed:
        usage: "GAUGE"
        description: "not used for clients"
    - ptr:
        usage: "LABEL"
        description: "Address of internal object for this connection. Used as unique ID"
    - link:
        usage: "LABEL"
        description: "Address of server connection the client is paired with"
    - remote_pid:
        usage: "GAUGE"
        description: "Process ID, in case client connects over Unix socket and OS supports getting it"
    - tls:
        usage: "LABEL"
        description: "A string with TLS connection information, or empty if not using TLS"

pgbouncer_show_pools:
  master: true
  query: |
    SELECT _.database,
    _."user",
    _.cl_active,
    _.cl_waiting,
    _.cl_active_cancel_req,
    _.cl_waiting_cancel_req,
    _.sv_active,
    _.sv_active_cancel,
    _.sv_being_canceled,
    _.sv_idle,
    _.sv_used,
    _.sv_tested,
    _.sv_login,
    _.maxwait,
    _.maxwait_us,
    _.pool_mode
    FROM dblink('host=/var/run/postgresql port=6432 dbname=pgbouncer user=pgbouncer', 'show pools'::text)
    _(database text, "user" text, cl_active integer, cl_waiting integer, cl_active_cancel_req integer, cl_waiting_cancel_req integer, sv_active integer, sv_active_cancel integer, sv_being_canceled integer, sv_idle integer,
    sv_used integer, sv_tested integer, sv_login integer, maxwait integer, maxwait_us integer, pool_mode text);
  metrics:
    - database:
        usage: "LABEL"
        description: "Database name"
    - user:
        usage: "LABEL"
        description: "User name"
    - cl_active:
        usage: "GAUGE"
        description: "Client connections that are linked to server connection and can process queries"
    - cl_waiting:
        usage: "GAUGE"
        description: "Client connections that have sent queries but have not yet got a server connection"
    - cl_active_cancel_req:
        usage: "GAUGE"
        description: "Client connections that have forwarded query cancellations to the server and are waiting for the server response"
    - cl_waiting_cancel_req:
        usage: "GAUGE"
        description: "Client connections that have not forwarded query cancellations to the server yet"
    - sv_active:
        usage: "GAUGE"
        description: "Server connections that are linked to a client"
    - sv_active_cancel:
        usage: "GAUGE"
        description: "Server connections that are currently forwarding a cancel request"
    - sv_being_canceled:
        usage: "GAUGE"
        description: "Servers that normally could become idle but are waiting to do so until all in-flight cancel requests have completed that were sent to cancel a query on this server"
    - sv_idle:
        usage: "GAUGE"
        description: "Server connections that are unused and immediately usable for client queries"
    - sv_used:
        usage: "GAUGE"
        description: "Server connections that have been idle for more than server_check_delay so they need server_check_query to run on them"
    - sv_tested:
        usage: "GAUGE"
        description: "Server connections that are currently running either server_reset_query or server_check_query"
    - sv_login:
        usage: "GAUGE"
        description: "Server connections currently in the process of logging in"
    - maxwait:
        usage: "GAUGE"
        description: "How long the first oldest client in the queue has waited, in seconds"
    - maxwait_us:
        usage: "GAUGE"
        description: "Microsecond part of the maximum waiting time"
    - pool_mode:
        usage: "LABEL"
        description: "The pooling mode in use"

pgbouncer_show_databases:
  master: true
  query: |
    select _.name,
    _.host,
    _.port,
    _.database,
    _.force_user,
    _.pool_size,
    _.reserve_pool,
    _.pool_mode,
    _.max_connections,
    _.current_connections,
    _.paused,
    _.disabled
    FROM dblink('host=/var/run/postgresql port=6432 dbname=pgbouncer user=pgbouncer', 'show databases'::text)
    _(name text, host text, port integer, database text, force_user text, pool_size integer, reserve_pool integer,
    pool_mode text, max_connections integer, current_connections integer, paused boolean, disabled boolean);
  metrics:
    - name:
        usage: "LABEL"
        description: "Name of configured database entry"
    - host:
        usage: "LABEL"
        description: "Host pgbouncer connects to"
    - port:
        usage: "GAUGE"
        description: "Port pgbouncer connects to"
    - database:
        usage: "LABEL"
        description: "Actual database name pgbouncer connects to."
    - force_user:
        usage: "LABEL"
        description: "When the user is part of the connection string the connection between pgbouncer and PostgreSQL is forced to the given user"
    - pool_size:
        usage: "GAUGE"
        description: "Maximum number of server connections"
    - reserve_pool:
        usage: "GAUGE"
        description: "Maximum number of additional connections for this database"
    - pool_mode:
        usage: "LABEL"
        description: "The database override pool_mode"
    - max_connections:
        usage: "GAUGE"
        description: "Maximum number of allowed connections for this database"
    - current_connections:
        usage: "GAUGE"
        description: "Current number of connections for this database"
    - paused:
        usage: "GAUGE"
        description: "1 if this database is currently paused, else 0"
    - disabled:
        usage: "GAUGE"
        description: "1 if this database is currently paused, else 0"

pgbouncer_show_stats_totals:
  master: true
  query: |
    select _.database,
    _.xact_count,
    _.query_count,
    _.bytes_received,
    _.bytes_sent,
    _.xact_time,
    _.query_time,
    _.wait_time
    FROM dblink('host=/var/run/postgresql port=6432 dbname=pgbouncer user=pgbouncer', 'show stats_totals'::text)
    _(database text, xact_count bigint, query_count bigint, bytes_received bigint, bytes_sent bigint, xact_time bigint,
    query_time bigint, wait_time bigint);
  metrics:
    - database:
        usage: "LABEL"
        description: "Database name"
    - xact_count:
        usage: "GAUGE"
        description: "Number of SQL transactions pooled"
    - query_count:
        usage: "GAUGE"
        description: "Number of SQL queries pooled"
    - bytes_received:
        usage: "GAUGE"
        description: "Volume in bytes of network traffic received"
    - bytes_sent:
        usage: "GAUGE"
        description: "Volume in bytes of network traffic sent"
    - xact_time:
        usage: "GAUGE"
        description: "Number of microseconds spent by pgbouncer when connected to PostgreSQL in a transaction"
    - query_time:
        usage: "GAUGE"
        description: "Number of microseconds spent by pgbouncer when actively connected to PostgreSQL"
    - wait_time:
        usage: "GAUGE"
        description: "Time spent by clients waiting for a server, in microseconds"

pgbouncer_show_stats:
  master: true
  query: |
    select _.database,
    _.total_xact_count,
    _.total_query_count,
    _.total_received,
    _.total_sent,
    _.total_xact_time,
    _.total_query_time,
    _.total_wait_time,
    _.avg_xact_count,
    _.avg_query_count,
    _.avg_recv,
    _.avg_sent,
    _.avg_xact_time,
    _.avg_query_time,
    _.avg_wait_time
    FROM dblink('host=/var/run/postgresql port=6432 dbname=pgbouncer user=pgbouncer', 'show stats'::text)
    _(database text, total_xact_count bigint, total_query_count bigint, total_received bigint, total_sent bigint,total_xact_time bigint, total_query_time bigint,
    total_wait_time bigint, avg_xact_count bigint, avg_query_count bigint, avg_recv bigint, avg_sent bigint, avg_xact_time bigint, avg_query_time bigint,
    avg_wait_time bigint);
  metrics:
    - database:
        usage: "LABEL"
        description: "Database name"
    - total_xact_count:
        usage: "GAUGE"
        description: "Total number of SQL transactions pooled"
    - total_query_count:
        usage: "GAUGE"
        description: "Total number of SQL queries pooled"
    - total_received:
        usage: "GAUGE"
        description: "Total volume in bytes of network traffic received"
    - total_sent:
        usage: "GAUGE"
        description: "Total volume in bytes of network traffic sent"
    - total_xact_time:
        usage: "GAUGE"
        description: "Total number of microseconds spent by pgbouncer when connected to PostgreSQL in a transaction"
    - total_query_time:
        usage: "GAUGE"
        description: "Total number of microseconds spent by pgbouncer when actively connected to PostgreSQL"
    - total_wait_time:
        usage: "GAUGE"
        description: "Time spent by clients waiting for a server, in microseconds"
    - avg_xact_count:
        usage: "GAUGE"
        description: "Average transactions per second in last stat period"
    - avg_query_count:
        usage: "GAUGE"
        description: "Average queries per second in last stat period"
    - avg_recv:
        usage: "GAUGE"
        description: "Average received from clients bytes per second"
    - avg_sent:
        usage: "GAUGE"
        description: "Average sent to clients bytes per second"
    - avg_xact_time:
        usage: "GAUGE"
        description: "Average transaction duration, in microseconds"
    - avg_query_time:
        usage: "GAUGE"
        description: "Average query duration, in microseconds"
    - avg_wait_time:
        usage: "GAUGE"
        description: "Time spent by clients waiting for a server, in microseconds average per second"

node_filesystem:
  master: true
  query: |
    WITH mounts AS (
      SELECT columns[1] AS device,
        columns[2] AS mountpoint
        FROM (SELECT regexp_split_to_array(line, E'\\s+') AS columns
            FROM mounts() AS line) AS mounts
      WHERE columns[2] LIKE '/var/%')
    SELECT CASE WHEN columns[1] <> '-' THEN columns[1] ELSE NULL END AS device,
        CASE WHEN columns[2] <> '-' THEN columns[2] ELSE NULL END AS mountpoint,
        CASE WHEN columns[3] <> '-' THEN columns[3] ELSE NULL END AS fstype,
        CASE WHEN columns[4] <> '-' THEN columns[4] ELSE NULL END AS size_bytes,
        CASE WHEN columns[5] <> '-' THEN columns[5] ELSE NULL END AS avail_bytes,
        CASE WHEN columns[6] <> '-' THEN columns[6] ELSE NULL END AS files,
        CASE WHEN columns[7] <> '-' THEN columns[7] ELSE NULL END AS files_free,
        CASE WHEN columns[8] <> '-' AND columns[8] <> 'timeout' THEN TRUE ELSE FALSE END AS device_error
      FROM (SELECT regexp_split_to_array(line, E'\\s+') AS columns
          FROM (SELECT df(mountpoint) AS line FROM mounts) AS df) AS df
  metrics:
    - device:
        usage: "LABEL"
        description: "Device of the filesystem."
    - mountpoint:
        usage: "LABEL"
        description: "Mount point of the filesystem."
    - fstype:
        usage: "LABEL"
        description: "The type of filesystem."
    - size_bytes:
        usage: "GAUGE"
        description: "Filesystem size in bytes."
    - avail_bytes:
        usage: "GAUGE"
        description: "Filesystem space available to non-root users in bytes."
    - files:
        usage: "GAUGE"
        description: "Filesystem total file nodes."
    - files_free:
        usage: "GAUGE"
        description: "Filesystem total free file nodes."
    - device_error:
        usage: "GAUGE"
        description: "Whether an error occurred while getting statistics for the given device."

# PG_STAT_STATEMENT
pg_statements:
  query: |
    SELECT
        pg_database.datname,
        pg_roles.rolname as usename,
        pg_stat_statements.queryid,
        pg_stat_statements.calls as calls_total,
        pg_stat_statements.total_exec_time / 1000 as total_exec_time,
        pg_stat_statements.mean_exec_time / 1000  as mean_exec_time,
        pg_stat_statements.rows as rows_total
    FROM pg_stat_statements
    JOIN pg_roles ON (pg_stat_statements.userid = pg_roles.oid)
    JOIN pg_database ON (pg_stat_statements.dbid = pg_database.oid)
    WHERE calls > 1
    ORDER BY
        pg_stat_statements.total_exec_time - pg_stat_statements.mean_exec_time * pg_stat_statements.calls desc
    LIMIT 20
    ;
  master: true
  metrics:
    - datname:
        usage: "LABEL"
        description: "Database name"
    - usename:
        usage: "LABEL"
        description: "User name"
    - queryid:
        usage: "LABEL"
        description: "Query ID"
    - calls_total:
        usage: "GAUGE"
        description: "Total calls of the query"
    - total_exec_time:
        usage: "GAUGE"
        description: "Total execute time in milliseconds"
    - mean_exec_time:
        usage: "GAUGE"
        description: "Total mean time in milliseconds"
    - rows_total:
        usage: "GAUGE"
        description: "Total rows returned"
